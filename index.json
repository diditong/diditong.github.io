[{"authors":["admin"],"categories":null,"content":"Jiashuo Tong is a student in Mechanical Engineering with a concentration in Computational Science and Engineering, at University of Illinois Urbana-Champaign.\n","date":1441065600,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1441065600,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://diditong.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Jiashuo Tong is a student in Mechanical Engineering with a concentration in Computational Science and Engineering, at University of Illinois Urbana-Champaign.","tags":null,"title":"Jiashuo Tong","type":"authors"},{"authors":null,"categories":null,"content":"ssss content/project/FEM And Deep Learning/f2.png\n","date":1573777341,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1573777341,"objectID":"d9f997f10924b859d541c8017dbbcd75","permalink":"https://diditong.github.io/project/fem-and-deep-learning/","publishdate":"2019-11-15T00:22:21Z","relpermalink":"/project/fem-and-deep-learning/","section":"project","summary":"ssss content/project/FEM And Deep Learning/f2.png","tags":["Finite Element Method, Deep Learning"],"title":"FEM And Deep Learning For Solving PDE's","type":"project"},{"authors":null,"categories":null,"content":"ssss\n","date":1573777341,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1573777341,"objectID":"5f35530a8ab99cd404e3df34115ebdb3","permalink":"https://diditong.github.io/project/gan-for-style-transfer/","publishdate":"2019-11-15T00:22:21Z","relpermalink":"/project/gan-for-style-transfer/","section":"project","summary":"ssss","tags":["GAN, Deep Learning"],"title":"GAN For Style Transfer","type":"project"},{"authors":null,"categories":null,"content":"ssss\n","date":1573777341,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1573777341,"objectID":"a00c12dd342f2ca2f5c265cce704c5f6","permalink":"https://diditong.github.io/project/photo-mosaic/","publishdate":"2019-11-15T00:22:21Z","relpermalink":"/project/photo-mosaic/","section":"project","summary":"ssss","tags":["KDTree, Data Structure"],"title":"Photo Mosaic","type":"project"},{"authors":null,"categories":null,"content":"This is a documentation for my implementations of algorithms I learned from classes 1. Karatsuba Multiplication def KaraMult(x,y): if len(str(x)) == 1 or len(str(y)) == 1: return x*y else: n = max(len(str(x)),len(str(y))) n2 = n // 2 a = x // 10**(n2) b = x % 10**(n2) c = y // 10**(n2) d = y % 10**(n2) ac = KaraMult(a,c) bd = KaraMult(b,d) ad_plus_bc = KaraMult(a+b,c+d) - ac - bd prod = ac * 10**(2*n2) + (ad_plus_bc * 10**n2) + bd return prod  2. Merge Sort def mergesort(alist): if (len(alist)\u0026gt;1): mid = len(alist)//2 lefthalf = alist[:mid] righthalf = alist[mid:] mergesort(lefthalf) mergesort(righthalf) i,j,k=0,0,0 while (i\u0026lt;len(lefthalf) and j\u0026lt;len(righthalf)): if (lefthalf[i]\u0026lt;righthalf[j]): alist[k]=lefthalf[i] i+=1 else: alist[k]=righthalf[j] j+=1 k+=1 while(i\u0026lt;len(lefthalf)): alist[k]=lefthalf[i] i+=1 k+=1 while(j\u0026lt;len(righthalf)): alist[k]=righthalf[j] j+=1 k+=1  3. Merge Sort (returns sorted list) def mergesort(alist): if (len(alist)\u0026gt;1): mid = len(alist)//2 lefthalf = alist[:mid] righthalf = alist[mid:] mergesort(lefthalf) mergesort(righthalf) i,j,k=0,0,0 while (i\u0026lt;len(lefthalf) and j\u0026lt;len(righthalf)): if (lefthalf[i]\u0026lt;righthalf[j]): alist[k]=lefthalf[i] i+=1 else: alist[k]=righthalf[j] j+=1 k+=1 while(i\u0026lt;len(lefthalf)): alist[k]=lefthalf[i] i+=1 k+=1 while(j\u0026lt;len(righthalf)): alist[k]=righthalf[j] j+=1 k+=1  4. Quick Sort (with the last element as the pivot) {% highlight python %} import numpy as np def swap(array,m,n): a = array[m] array[m] = array[n] array[n] = a def quickSort(array,l,r): if (l\u0026lt;r): swap(array,r,l) #always set the final element as the pivot p = partition(array,l,r) quickSort(array,l,p-1) quickSort(array,p+1,r) def partition(array,l,r): pivot = array[l] #stat.median([array[l],array[(l+r)//2],array[r]]) i = l+1 for j in range(l+1,r+1): if (array[j] \u0026lt; pivot): swap(array,i,j) i+=1 swap(array,i-1,l) return i-1  5. Count Inversions (with mergeSort() subroutine) def mergeSort(alist): right = len(alist) mid = right//2 if (right == 1): return alist if (0 \u0026lt; mid): lefthalf = mergeSort(alist[:mid]) if (mid \u0026lt; right): righthalf = mergeSort(alist[mid:]) i=0 j=0 sortedlist = [] while(i\u0026lt;mid and j\u0026lt;right-mid): if(lefthalf[i]\u0026lt;=righthalf[j]): sortedlist.append(lefthalf[i]) i+=1 else: sortedlist.append(righthalf[j]) j+=1 while(i\u0026lt;mid): sortedlist.append(lefthalf[i]) i+=1 while(j\u0026lt;right-mid): sortedlist.append(righthalf[j]) j+=1 return sortedlist def countInversions(array): if (len(array)==1): return 0 mid = len(array)//2 num_invs_left = countInversions(array[:mid]) num_invs_right = countInversions(array[mid:]) lefthalf = mergeSort(array[:mid]) righthalf = mergeSort(array[mid:]) i=j=0 num_invs_between = 0 while (j\u0026lt;len(righthalf) and i\u0026lt;len(lefthalf)): if (righthalf[j]\u0026gt;lefthalf[i]): i+=1 else: num_invs_between+=len(lefthalf)-i j+=1 return num_invs_left+num_invs_right+num_invs_between  6. RSelect (Random Select with partition subroutine) def swap(array,m,n): a = array[m] array[m] = array[n] array[n] = a def partition(array,l,r): i_pivot = np.random.randint(r) swap(array,i_pivot,l) pivot = array[l] #stat.median([array[l],array[(l+r)//2],array[r]]) i = l+1 for j in range(l+1,r): if (array[j] \u0026lt; pivot): swap(array,i,j) i+=1 swap(array,l,i-1) return i def RSelect(A,i): length = len(A) if length == 1: return A[i] j = partition(A,0,length) if j+1 == i: return A[j] elif j+1 \u0026lt; i: return RSelect(A[j:],i-j) else: return RSelect(A[0:j],i) for i in range(1000): kargerDict = backupDict.copy() for i in range(198): #Remove the chosen connection from the dictionary delete = list(kargerDict)[np.random.randint(len(kargerDict))] i1 = delete[0] i2 = delete[1] del kargerDict[delete] #Transfer the count from old connections to new connections for old_key in kargerDict.copy(): x,y = old_key[0],old_key[1] if x == i2: m = i1 n = y elif y == i2: m = i1 n = x else: continue m,n = sorted([m,n]) new_key = (m,n) if new_key in kargerDict.keys(): kargerDict[new_key] += kargerDict[old_key] else: kargerDict[new_key] = kargerDict[old_key] del kargerDict[old_key] if mincut \u0026gt; list(kargerDict.values())[0]: mincut = list(kargerDict.values())[0] print(\u0026quot;Cut for current iteration is: \u0026quot;, mincut)  7. Karger algorithm for counting minimum cut kargerDict = {} #Read the text file into a dictionary with open('kargerMinCut.txt', 'r') as f: i = 0 while i \u0026lt; 200: line = f.readline() line = line.split('\\t') line = line[:-1] idx = 0 for string in line: line[idx] = int(string) idx += 1 m = line[0] for j in range(1,len(line)): n = line[j] if n \u0026gt; m: kargerDict[(m,n)] = 1 i += 1 for i in range(1,201): for j in range(i+1,201): if (i,j) not in kargerDict.keys(): kargerDict[(i,j)] = 0 #Backup the dictionary for further processing backupDict = kargerDict mincut = 10000 for i in range(1000): kargerDict = backupDict.copy() for i in range(198): #Remove the chosen connection from the dictionary delete = list(kargerDict)[np.random.randint(len(kargerDict))] i1 = delete[0] i2 = delete[1] del kargerDict[delete] #Transfer the count from old connections to new connections for old_key in kargerDict.copy(): x,y = old_key[0],old_key[1] if x == i2: m = i1 n = y elif y == i2: m = i1 n = x else: continue m,n = sorted([m,n]) new_key = (m,n) if new_key in kargerDict.keys(): kargerDict[new_key] += kargerDict[old_key] else: kargerDict[new_key] = kargerDict[old_key] del kargerDict[old_key] if mincut \u0026gt; list(kargerDict.values())[0]: mincut = list(kargerDict.values())[0] print(\u0026quot;Cut for current iteration is: \u0026quot;, mincut)  8. Dijkstra's Algorithm #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;limits\u0026gt; using namespace std; struct Edge { int dest, weight; }; struct AdjList { int src; vector\u0026lt;Edge\u0026gt; list; }; struct Node { int idx; int dist; bool visited; }; class Graph { public: vector\u0026lt;Node\u0026gt; nodes; vector\u0026lt;AdjList\u0026gt; graph; Graph(string filename); int getSize(); vector\u0026lt;int\u0026gt; Dijkstra(int start, vector\u0026lt;int\u0026gt; ends); int setMinNode(); bool existNonVisited(); }; vector\u0026lt;string\u0026gt; split(string\u0026amp; line, char delimiter) { vector\u0026lt;string\u0026gt; v; string token; for (char const c: line) { if (c == delimiter) { v.push_back(token); token.clear(); } else { token += c; } } v.push_back(token); return v; } Graph::Graph(string filename) { string line; ifstream myfile(filename); if (myfile.is_open()) { while ( getline(myfile,line) ) { //Read a single line into edge and list vector\u0026lt;string\u0026gt; splt1 = split(line, ' '); splt1.pop_back(); AdjList l; l.src = stoi(splt1[0]); for (int i=1; i\u0026lt;splt1.size(); i++) { vector\u0026lt;string\u0026gt; splt2 = split(splt1[i], ','); Edge e;\te.dest = stoi(splt2[0]); e.weight = stoi(splt2[1]); l.list.push_back(e); } graph.push_back(l); } myfile.close(); } } int Graph::getSize() { return graph.size(); } int Graph::setMinNode() { int min_idx = 0; for (int curr_idx=1; curr_idx\u0026lt;nodes.size(); curr_idx++) {\t//cout \u0026lt;\u0026lt; \u0026quot;From setMinNode: Node \u0026quot; \u0026lt;\u0026lt; curr_idx \u0026lt;\u0026lt; \u0026quot; is visited? \u0026quot; \u0026lt;\u0026lt; nodes[curr_idx].visited \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026quot;From setMinNode: Node \u0026quot; \u0026lt;\u0026lt; curr_idx \u0026lt;\u0026lt; \u0026quot; has a value \u0026quot; \u0026lt;\u0026lt; nodes[curr_idx].dist \u0026lt;\u0026lt; endl; if (!nodes[curr_idx].visited) { // \u0026lt;\u0026lt; \u0026quot;curr_idx is \u0026quot; \u0026lt;\u0026lt; curr_idx \u0026lt;\u0026lt; \u0026quot;, dist is \u0026quot; \u0026lt;\u0026lt; nodes[curr_idx].dist \u0026lt;\u0026lt; endl; if (nodes[curr_idx].dist \u0026lt; nodes[min_idx].dist) { min_idx = curr_idx; } } } //cout \u0026lt;\u0026lt; \u0026quot;Minimum Index is \u0026quot; \u0026lt;\u0026lt; min_idx \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026quot;returned min_idx is \u0026quot; \u0026lt;\u0026lt; min_idx \u0026lt;\u0026lt; endl; return min_idx; } bool Graph::existNonVisited() { for (int curr_idx=1; curr_idx\u0026lt;nodes.size(); curr_idx++) { if (nodes[curr_idx].visited == false) { return true; } } return false; } vector\u0026lt;int\u0026gt; Graph::Dijkstra(int start, vector\u0026lt;int\u0026gt; ends) { //Mark initial node with a weight 0. Mark the rest nodes with infinity. Node firstNode = { 0, numeric_limits\u0026lt;int\u0026gt;::max(), true }; nodes.push_back(firstNode); // int sz = graph.size(); Node n = { 1, 0, false }; nodes.push_back(n); for (int i=2; i\u0026lt;=sz ; i++) { Node n = { i, numeric_limits\u0026lt;int\u0026gt;::max(), false }; nodes.push_back(n); } while (existNonVisited()) { //Set the non-visited node with the minimum current distance as the current node C. int c_idx = setMinNode(); //For each neighbor n, add c with c-n. If smaller than current weight of n, set it as //new distance of n. for (Edge e : graph[c_idx-1].list) { //cout \u0026lt;\u0026lt; \u0026quot;Size of the list is \u0026quot; \u0026lt;\u0026lt; graph[c_idx-1].list.size() \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026quot;dest \u0026quot; \u0026lt;\u0026lt; e.dest \u0026lt;\u0026lt; \u0026quot; is visited? \u0026quot; \u0026lt;\u0026lt; nodes[e.dest].visited \u0026lt;\u0026lt; endl; if (!nodes[e.dest].visited) { //cout \u0026lt;\u0026lt; \u0026quot;node \u0026quot; \u0026lt;\u0026lt; c_idx \u0026lt;\u0026lt; \u0026quot; is compared to \u0026quot; \u0026lt;\u0026lt; e.dest \u0026lt;\u0026lt; endl; if (nodes[c_idx].dist + e.weight \u0026lt; nodes[e.dest].dist) { nodes[e.dest].dist = nodes[c_idx].dist + e.weight; } } } //set current node to be visited //cout \u0026lt;\u0026lt; nodes[c_idx].idx \u0026lt;\u0026lt; endl; nodes[c_idx].visited = true; } //Generate the final distance list for output vector\u0026lt;int\u0026gt; shortestDistances; for (int end : ends) { shortestDistances.push_back(nodes[end].dist); } return shortestDistances; } int main() { Graph G = Graph(\u0026quot;dijkstraData.txt\u0026quot;); //cout \u0026lt;\u0026lt; G.graph[0].list[0].weight \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt; endpoints = {7,37,59,82,99,115,133,165,188,197}; for (int distance : G.Dijkstra(1,endpoints)) { cout \u0026lt;\u0026lt; distance \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; return 0; }  Did you find this page helpful? Consider sharing it ðŸ™Œ ","date":1571097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571097600,"objectID":"f82f6a76c7f604e53a677b6b648cb165","permalink":"https://diditong.github.io/post/algorithms/","publishdate":"2019-10-15T00:00:00Z","relpermalink":"/post/algorithms/","section":"post","summary":"This is a documentation for my implementations of algorithms I learned from classes 1. Karatsuba Multiplication def KaraMult(x,y): if len(str(x)) == 1 or len(str(y)) == 1: return x*y else: n = max(len(str(x)),len(str(y))) n2 = n // 2 a = x // 10**(n2) b = x % 10**(n2) c = y // 10**(n2) d = y % 10**(n2) ac = KaraMult(a,c) bd = KaraMult(b,d) ad_plus_bc = KaraMult(a+b,c+d) - ac - bd prod = ac * 10**(2*n2) + (ad_plus_bc * 10**n2) + bd return prod  2.","tags":null,"title":"Jiashuo's Programming Exercise","type":"post"},{"authors":null,"categories":null,"content":"This is a documentation for LeetCodes LeetCode 009 #include \u0026lt;iostream\u0026gt; using namespace std; /*Revert the whole number //Problematic for very large number bool isPalindrome(int x) { if (x \u0026lt; 0) return false; int x1 = x; int x2 = 0; int lastdig = 0; while (x != 0) { lastdig = x%10; x = x/10; x2 = x2*10+lastdig; } if (x1 == x2) return true; else return false; } */ //Revert half of the number bool isPalindrome(int x) { if (x \u0026lt; 0) return false; //special case: x = 0 or x = 10; if (x \u0026gt; 0 \u0026amp;\u0026amp; x%10 == 0) return false; int x1 = x; int x2 = 0; while (x1 \u0026gt; x2) { x2 = x2*10 + x1%10; x1 = x1/10; } if (x1 == x2) return true; if (x2/10 == x1) return true; return false; } int main() { cout \u0026lt;\u0026lt; isPalindrome(123321) \u0026lt;\u0026lt; endl;\treturn 0; }  LeetCode 011 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; /* int calculateArea(int h1, int h2, dis) { int h = min(h1,h2); int area = h*dis; return area; } */\tint maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int len = height.size(); int l = 0; int r = len-1; int area = 0; while (l \u0026lt; r) { area = max(area, min(height[l],height[r])*(r-l)); if (height[l]\u0026lt;height[r]) { l++; } else { r--; } } return area; } int main(){ vector\u0026lt;int\u0026gt; sides; sides.push_back(1); sides.push_back(8); sides.push_back(6); sides.push_back(2); sides.push_back(5); sides.push_back(4); sides.push_back(8); sides.push_back(3); sides.push_back(7); int Amax = maxArea(sides); cout \u0026lt;\u0026lt; Amax \u0026lt;\u0026lt; endl; return 0; }  LeetCode 017 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; void helper(vector\u0026lt;string\u0026gt; \u0026amp;vec, string str, int nos) { if (nos == 0) { vec.push_back(str); return; } //Update last digit and remaining number int lastdig = nos % 10; nos = nos/10; //Map the last digit to ASCII values //Number 7, 8 and 9 are special cases if (lastdig == 7) { helper(vec, char(112) + str, nos); helper(vec, char(113) + str, nos); helper(vec, char(114) + str, nos); helper(vec, char(115) + str, nos); } else if (lastdig == 8) { helper(vec, char(116) + str, nos); helper(vec, char(117) + str, nos); helper(vec, char(118) + str, nos); } else if (lastdig == 9) { helper(vec, char(119) + str, nos); helper(vec, char(120) + str, nos); helper(vec, char(121) + str, nos); helper(vec, char(122) + str, nos); } else { int ascii1 = 3*lastdig+91; int ascii2 = 3*lastdig+92; int ascii3 = 3*lastdig+93; //Convert the ASCII values to characters //Run the recursion function helper until the condition nos = 0 is met helper(vec, char(ascii1) + str, nos); helper(vec, char(ascii2) + str, nos); helper(vec, char(ascii3) + str, nos); } } //Encounted error (solved): terminate called after throwing an instance of 'std::invalid_argument' //what(): stoi //Never forget to consider trivial cases vector\u0026lt;string\u0026gt; letterCombinations(string digits) { vector\u0026lt;string\u0026gt; combos; if (digits == \u0026quot;\u0026quot;) {} else { int numbers = std::stoi(digits); helper(combos, \u0026quot;\u0026quot;, numbers); } return combos; } int main() { vector\u0026lt;string\u0026gt; letcoms = letterCombinations(\u0026quot;\u0026quot;); for (vector\u0026lt;string\u0026gt;::iterator it = letcoms.begin(); it != letcoms.end(); ++it) { cout \u0026lt;\u0026lt; *it\u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; }  LeetCode 021 // Header file for input output functions #include\u0026lt;iostream\u0026gt; using namespace std; // Definition for singly-linked list. /* struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; */ #include \u0026quot;ListNode.h\u0026quot; ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* c1 = l1; ListNode* c2 = l2; ListNode* curr = NULL; ListNode* Merged = NULL; if (l1 == NULL \u0026amp;\u0026amp; l2 == NULL) {return NULL;} if (l1 == NULL \u0026amp;\u0026amp; l2 != NULL) {return l2;} if (l1 != NULL \u0026amp;\u0026amp; l2 == NULL) {return l1;} if (l1-\u0026gt;val \u0026lt;= l2-\u0026gt;val) { Merged = new ListNode(l1-\u0026gt;val); curr = Merged; c1 = c1-\u0026gt;next; } else { Merged = new ListNode(l2-\u0026gt;val); curr = Merged; c2 = c2-\u0026gt;next; } while (c1 != NULL \u0026amp;\u0026amp; c2 != NULL) { cout \u0026lt;\u0026lt; \u0026quot;Reached Here1\u0026quot; \u0026lt;\u0026lt; endl; if (c1-\u0026gt;val \u0026lt;= c2-\u0026gt;val){ cout \u0026lt;\u0026lt; \u0026quot;Reached Here2\u0026quot; \u0026lt;\u0026lt; endl; ListNode* NewNode = new ListNode(c1-\u0026gt;val); curr-\u0026gt;next = NewNode; c1 = c1-\u0026gt;next; } else { curr-\u0026gt;next = new ListNode(c2-\u0026gt;val); c2 = c2-\u0026gt;next; } curr = curr-\u0026gt;next; } if (c1 == NULL) { while (c2 != NULL){ curr-\u0026gt;next = new ListNode(c2-\u0026gt;val); c2 = c2-\u0026gt;next; curr = curr-\u0026gt;next; } } else if (c2 == NULL) { while (c1 != NULL){ curr-\u0026gt;next = new ListNode(c1-\u0026gt;val); c1 = c1-\u0026gt;next; curr = curr-\u0026gt;next; } } return Merged; } ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* h1 = l1; ListNode* h2 = l2; ListNode* h1t = NULL; ListNode* h2t = NULL; ListNode* head; int smaller; if (h1 == NULL) { return h2; } if (h2 == NULL) { return h1; } if (h2-\u0026gt;val \u0026lt; h1-\u0026gt;val) { head = h2; h2t = h2; h2 = h2-\u0026gt;next; h2t-\u0026gt;next = h1; smaller = 1; } else { head = h1; h1t = h1; h1 = h1-\u0026gt;next; h1t-\u0026gt;next = h2; smaller = 0; } while (h1!=NULL and h2!=NULL) { if (smaller == 1) { if (h2-\u0026gt;val \u0026lt; h1-\u0026gt;val) { h2t-\u0026gt;next = h2; h2t = h2; h2 = h2-\u0026gt;next; h2t-\u0026gt;next = h1; } else { h1t = h1; h1 = h1-\u0026gt;next; h1t-\u0026gt;next = h2; smaller = 0; } } else { if (h1-\u0026gt;val \u0026lt; h2-\u0026gt;val) { h1t-\u0026gt;next = h1; h1t = h1; h1 = h1-\u0026gt;next; h1t-\u0026gt;next = h2; } else { h2t = h2; h2 = h2-\u0026gt;next; h2t-\u0026gt;next = h1; smaller = 1; } } } return head; } // main function -0 // where the execution of program begins int main() { //Build two lists, l1 and l2 ListNode* l1 = new ListNode(1); ListNode* second1 = new ListNode(2); ListNode* third1 = new ListNode(4); l1-\u0026gt;next = second1; second1-\u0026gt;next = third1; ListNode* l2 = new ListNode(1); ListNode* second2 = new ListNode(3); ListNode* third2 = new ListNode(4); l2-\u0026gt;next = second2; second2-\u0026gt;next = third2; ListNode* MergedList = mergeTwoLists(l1,l2); for (ListNode* i = MergedList; i != NULL;) { cout \u0026lt;\u0026lt; i-\u0026gt;val \u0026lt;\u0026lt; endl; i = i-\u0026gt;next; } return 0; }  LeetCode 022 // Simple C++ program to display \u0026quot;Hello World\u0026quot; // Header file for input output functions #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; //NOTE: Must use ALIASING here. void helper (vector\u0026lt;string\u0026gt; \u0026amp;vec, string s, int p, int q, int n) { if (q == n) { vec.push_back(s); cout \u0026lt;\u0026lt; \u0026quot;Pushed string is \u0026quot; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;Vector address is \u0026quot; \u0026lt;\u0026lt; \u0026amp;vec \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;Vector size is \u0026quot; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; endl; return; } /*WRONG_METHOD: if (p == q \u0026amp;\u0026amp; p \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026quot;IF1: \u0026quot; \u0026lt;\u0026lt; \u0026quot;p = \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026quot;, q = \u0026quot; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; endl; helper(vec, s + \u0026quot;(\u0026quot;, p + 1, q, n); } else if (p == q \u0026amp;\u0026amp; p == n) { cout \u0026lt;\u0026lt; \u0026quot;IF2: \u0026quot; \u0026lt;\u0026lt; \u0026quot;p = \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026quot;, q = \u0026quot; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; endl; helper(vec, s + \u0026quot;)\u0026quot;, p, q + 1, n);\t} else { cout \u0026lt;\u0026lt; \u0026quot;IF3: \u0026quot; \u0026lt;\u0026lt; \u0026quot;p = \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026quot;, q = \u0026quot; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; endl; helper(vec, s + \u0026quot;(\u0026quot;, p + 1, q, n); helper(vec, s + \u0026quot;)\u0026quot;, p, q + 1, n); } */ if (p \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026quot;p = \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026quot; \u0026lt; \u0026quot; \u0026lt;\u0026lt; \u0026quot;n = \u0026quot; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; helper(vec, s + \u0026quot;(\u0026quot;, p + 1, q, n); } if (q \u0026lt; p) { cout \u0026lt;\u0026lt; \u0026quot;q = \u0026quot; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026quot; \u0026lt; \u0026quot; \u0026lt;\u0026lt; \u0026quot;p = \u0026quot; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; helper(vec, s + \u0026quot;)\u0026quot;, p, q + 1, n);\t} } vector\u0026lt;string\u0026gt; generateParentheses(int n) { vector\u0026lt;string\u0026gt; vectstr; helper(vectstr, \u0026quot;\u0026quot;, 0, 0, n); return vectstr; } void print(vector\u0026lt;string\u0026gt; const \u0026amp;input) { for (int i = 0; i \u0026lt; input.size(); i++) { std::cout \u0026lt;\u0026lt; input.at(i) \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } return; } int main () { vector\u0026lt;string\u0026gt; paracombo = generateParentheses(3); print(paracombo); return 0; }  LeetCode 023  LeetCode 024 #include \u0026lt;iostream\u0026gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; ListNode* swapPairs(ListNode* head) { cout \u0026lt;\u0026lt; \u0026quot;Address of head1 is \u0026quot; \u0026lt;\u0026lt; \u0026amp;head \u0026lt;\u0026lt; endl; //Never use this statement //head == NULL ! head-\u0026gt;next == NULL:\tif (head == NULL) { return head; } if (head-\u0026gt;next == NULL) { return head; } ListNode* curr1 = head; ListNode* curr2 = curr1-\u0026gt;next; head = curr2; ListNode* temp; while (curr2-\u0026gt;next!=NULL \u0026amp;\u0026amp; curr2-\u0026gt;next-\u0026gt;next!=NULL) { curr1-\u0026gt;next = curr2-\u0026gt;next-\u0026gt;next; temp = curr2-\u0026gt;next; curr2-\u0026gt;next = curr1; curr1 = temp; curr2 = temp-\u0026gt;next;\t} if (curr2-\u0026gt;next == NULL) { curr2-\u0026gt;next = curr1; curr1-\u0026gt;next = NULL; } else if (curr2-\u0026gt;next-\u0026gt;next == NULL) { temp = curr2-\u0026gt;next; curr2-\u0026gt;next = curr1; curr1-\u0026gt;next = temp; temp-\u0026gt;next = NULL; } return head; } void printList(ListNode* head) { cout \u0026lt;\u0026lt; \u0026quot;Address of head2 is \u0026quot; \u0026lt;\u0026lt; \u0026amp;head \u0026lt;\u0026lt; endl; ListNode* curr = head;\twhile(curr != NULL) { cout \u0026lt;\u0026lt; curr-\u0026gt;val \u0026lt;\u0026lt; \u0026quot; \u0026quot;; curr = curr-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; return; } int main() { ListNode* headNode = NULL; cout \u0026lt;\u0026lt; \u0026quot;Address of headNode is \u0026quot; \u0026lt;\u0026lt; \u0026amp;headNode \u0026lt;\u0026lt; endl; headNode = new ListNode(1); //headNode-\u0026gt;next = new ListNode(2); //headNode-\u0026gt;next-\u0026gt;next = new ListNode(3); //headNode-\u0026gt;next-\u0026gt;next-\u0026gt;next = new ListNode(4); printList(headNode); ListNode* swappedList = swapPairs(headNode); //printList(swappedList); }  LeetCode 025 #include \u0026lt;iostream\u0026gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; //Read carefully what the question is asking you to do ListNode* reverseKGroup(ListNode* head, int k) { if (head == NULL) return head; if (k == 0 | k == 1) return head; //Find size of list ListNode* curr = head; int sz = 0; while(curr != NULL) { curr = curr-\u0026gt;next; sz += 1; } cout \u0026lt;\u0026lt; \u0026quot;Size is \u0026quot; \u0026lt;\u0026lt; sz \u0026lt;\u0026lt; endl; ListNode* curr1 = head; ListNode* curr2 = curr1-\u0026gt;next; ListNode* temphead = head; for (int j=0; j\u0026lt;k-1; j++) { head = head-\u0026gt;next; } ListNode* temp; if (k \u0026gt; sz) k = sz; int n = sz/k; for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;k-1; j++) { temp = curr2-\u0026gt;next; curr2-\u0026gt;next = curr1; curr1 = curr2; curr2 = temp;\t} /*Modify this part temphead-\u0026gt;next = curr2; curr1 = curr2; curr2 = curr2-\u0026gt;next; temphead = temphead-\u0026gt;next; */ } cout \u0026lt;\u0026lt; \u0026quot;curr1 is \u0026quot; \u0026lt;\u0026lt; curr1-\u0026gt;val \u0026lt;\u0026lt; endl;\tcout \u0026lt;\u0026lt; \u0026quot;curr2 is \u0026quot; \u0026lt;\u0026lt; curr2-\u0026gt;val \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;temp is \u0026quot; \u0026lt;\u0026lt; temp-\u0026gt;val \u0026lt;\u0026lt; endl; return head; } void printList(ListNode* head) { ListNode* curr = head;\twhile(curr != NULL) { cout \u0026lt;\u0026lt; curr-\u0026gt;val \u0026lt;\u0026lt; \u0026quot; \u0026quot;; curr = curr-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; return; } int main() { ListNode* headNode = NULL; headNode = new ListNode(1); headNode-\u0026gt;next = new ListNode(2); headNode-\u0026gt;next-\u0026gt;next = new ListNode(3); headNode-\u0026gt;next-\u0026gt;next-\u0026gt;next = new ListNode(4); headNode-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next = new ListNode(5); headNode-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next = new ListNode(6); headNode-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next = new ListNode(7); headNode-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next-\u0026gt;next = new ListNode(8); printList(headNode); int K = 3; ListNode* reversedList = reverseKGroup(headNode, 3); printList(reversedList); }  LeetCode 035 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int spano = 0; vector\u0026lt;int\u0026gt;::iterator it; for (it = nums.begin(); it != nums.end(); it++) { if (target \u0026lt;= *it) { break; } spano += 1; } return spano; } int main() { vector\u0026lt;int\u0026gt; array; array.push_back(2); array.push_back(3); array.push_back(3); array.push_back(4); array.push_back(5); array.push_back(6); array.push_back(6); array.push_back(7); int pos = searchInsert(array, 5); cout \u0026lt;\u0026lt; pos \u0026lt;\u0026lt;endl; return 0; }  LeetCode 070 #include \u0026lt;iostream\u0026gt; using namespace std; //Using Combinations /* int climbStairs(int n) { if (n == 0) return 0; int ways = 1; int denominator = 1; int nominator = 1; int m = 0; for (int i = 1; i \u0026lt; n/2+1; i++) { m = (i \u0026lt; n-i) ? i : n-i; for (int j = 0; j \u0026lt; m; j++) { denominator *= n-i-j; nominator *= i-j; } ways += denominator/nominator; denominator = 1; nominator = 1; } return ways; } */ //Dynamic Programming int climbStairs(int n) { if (n == 0) return 0; if (n == 1) return 1; int step[n+1]; step[0] = 1; step[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { step[i] = step[i-1] + step[i-2]; } return step[n]; } //Brute force /* int climb_stairs(int i, int n) { if (i \u0026gt; n) { return 0; } if (i == n) { return 1; } return climb_stairs(i+1, n) + climb_stairs(i+2, n); } int climbStairs(int n) { return climb_stairs(0,n); } */ int main() { cout \u0026lt;\u0026lt; climbStairs(44) \u0026lt;\u0026lt; endl; return 0; }  LeetCode 101 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; ///Iterative Method bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); q.push(root); while (!q.empty()) { TreeNode* leftNode = q.front(); q.pop(); TreeNode* rightNode = q.front(); q.pop(); cout \u0026lt;\u0026lt; leftNode-\u0026gt;val \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; rightNode-\u0026gt;val \u0026lt;\u0026lt;endl; if (leftNode-\u0026gt;val!=rightNode-\u0026gt;val) return false; if (leftNode-\u0026gt;left!=NULL \u0026amp; rightNode-\u0026gt;right!=NULL) { q.push(leftNode-\u0026gt;left); q.push(rightNode-\u0026gt;right); } else if (leftNode-\u0026gt;left!=NULL | rightNode-\u0026gt;right!=NULL) { return false; } if (rightNode-\u0026gt;left!=NULL \u0026amp; leftNode-\u0026gt;right!=NULL) { q.push(rightNode-\u0026gt;left); q.push(leftNode-\u0026gt;right); } else if (rightNode-\u0026gt;left!=NULL | leftNode-\u0026gt;right!=NULL) { return false; } } return true; } int main() { TreeNode* rt = new TreeNode(0); rt-\u0026gt;left = new TreeNode(1); rt-\u0026gt;right = new TreeNode(1); rt-\u0026gt;left-\u0026gt;left = new TreeNode(3); rt-\u0026gt;left-\u0026gt;right = new TreeNode(4); rt-\u0026gt;right-\u0026gt;right = new TreeNode(3); rt-\u0026gt;right-\u0026gt;left = new TreeNode(4); vector\u0026lt;int\u0026gt; numList; bool is = isSymmetric(rt); cout \u0026lt;\u0026lt; \u0026quot;The Tree is symmetric?\u0026quot; \u0026lt;\u0026lt; is \u0026lt;\u0026lt; endl; return 0; }  LeetCode 102 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; /* vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; traversal; queue\u0026lt;TreeNode*\u0026gt; q; vector\u0026lt;int\u0026gt; children; if (root == NULL) return vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(); q.push(root); children.push_back(root-\u0026gt;val); traversal.push_back(children); while (!(q.empty())) { children = vector\u0026lt;int\u0026gt; (); int sz = q.size(); cout \u0026lt;\u0026lt; endl; for (int i=0; i\u0026lt;sz; i++) { TreeNode* currNode = q.front(); q.pop(); if (currNode-\u0026gt;left != NULL) { q.push(currNode-\u0026gt;left); children.push_back(currNode-\u0026gt;left-\u0026gt;val); } if (currNode-\u0026gt;right != NULL) { q.push(currNode-\u0026gt;right); children.push_back(currNode-\u0026gt;right-\u0026gt;val); } } if (!children.empty()) { traversal.push_back(children); } } return traversal; } */ void helper(TreeNode* subroot, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;traversal, int index) { if (subroot == NULL) return; if (index \u0026gt; traversal.size()) traversal.push_back(vector\u0026lt;int\u0026gt;()); helper(subroot-\u0026gt;left,traversal,index+1); traversal[index-1].push_back(subroot-\u0026gt;val); helper(subroot-\u0026gt;right,traversal,index+1); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; level_order; helper(root,level_order,1); return level_order; } int main() { TreeNode* rt = new TreeNode(1); rt-\u0026gt;left = new TreeNode(2); rt-\u0026gt;right = new TreeNode(3); rt-\u0026gt;left-\u0026gt;left = new TreeNode(4); rt-\u0026gt;right-\u0026gt;left = new TreeNode(6); rt-\u0026gt;right-\u0026gt;right = new TreeNode(7); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; TVS = levelOrder(rt); for (int i=0; i\u0026lt;TVS.size(); i++) { for (int j=0; j\u0026lt;TVS[i].size(); j++) { cout \u0026lt;\u0026lt; TVS[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; } return 0; }  LeetCode 103 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; /*Iterative Method vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; traversal; stack\u0026lt;TreeNode*\u0026gt; s1; stack\u0026lt;TreeNode*\u0026gt; s2; vector\u0026lt;int\u0026gt; children; if (root == NULL) return vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(); s1.push(root); int reverse = 0; while (!(s1.empty() \u0026amp; s2.empty())) { children = vector\u0026lt;int\u0026gt;(); int sz1 = s1.size(); int sz2 = s2.size(); TreeNode* currNode; if (reverse%2 == 0) { for (int i = 0; i \u0026lt; sz1; i++) { currNode = s1.top(); s1.pop(); children.push_back(currNode-\u0026gt;val); if (currNode-\u0026gt;left != NULL) { s2.push(currNode-\u0026gt;left); } if (currNode-\u0026gt;right != NULL) { s2.push(currNode-\u0026gt;right); } } } else { for (int i = 0; i \u0026lt; sz2; i++) { currNode = s2.top(); s2.pop(); children.push_back(currNode-\u0026gt;val); if (currNode-\u0026gt;right != NULL) { s1.push(currNode-\u0026gt;right); } if (currNode-\u0026gt;left != NULL) { s1.push(currNode-\u0026gt;left); } } } traversal.push_back(children); reverse += 1; } return traversal; } */ void helper(TreeNode* subroot, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;traversal, int index) { if (subroot == NULL) return; if (index \u0026gt; traversal.size()) traversal.push_back(vector\u0026lt;int\u0026gt;()); helper(subroot-\u0026gt;left,traversal,index+1); if (index%2 == 1) traversal[index-1].push_back(subroot-\u0026gt;val); else traversal[index-1].insert(traversal[index-1].begin(),subroot-\u0026gt;val); helper(subroot-\u0026gt;right,traversal,index+1); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; level_order; helper(root,level_order,1); return level_order; } int main() { TreeNode* rt = new TreeNode(1); rt-\u0026gt;left = new TreeNode(2); rt-\u0026gt;right = new TreeNode(3); rt-\u0026gt;left-\u0026gt;left = new TreeNode(4); rt-\u0026gt;right-\u0026gt;left = new TreeNode(6); rt-\u0026gt;right-\u0026gt;right = new TreeNode(7); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; TVS = zigzagLevelOrder(rt); for (int i=0; i\u0026lt;TVS.size(); i++) { for (int j=0; j\u0026lt;TVS[i].size(); j++) { cout \u0026lt;\u0026lt; TVS[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; } return 0; }  LeetCode 104 #include\u0026lt;iostream\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; /*Recursive Method int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1+max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } */ //Iterative Method int maxDepth(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; q; int layers = 0; if (root == NULL) return 0; q.push(root); while (!(q.empty())) { int sz = q.size(); for (int i=0; i\u0026lt;sz; i++) { TreeNode* currNode = q.front(); q.pop(); if (currNode-\u0026gt;left != NULL) { q.push(currNode-\u0026gt;left); } if (currNode-\u0026gt;right != NULL) { q.push(currNode-\u0026gt;right); } } layers++; } return layers; } int main() { TreeNode* root = new TreeNode(3); root-\u0026gt;left = new TreeNode(9); root-\u0026gt;right = new TreeNode(20); root-\u0026gt;right-\u0026gt;left = new TreeNode(15); root-\u0026gt;right-\u0026gt;right = new TreeNode(7); cout \u0026lt;\u0026lt; maxDepth(root) \u0026lt;\u0026lt; endl; }  LeetCode 105 #include\u0026lt;iostream\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { if (preorder.empty()) { return NULL; } int start = 0; int end = preorder.size(); TreeNode* root = helper(preorder, inorder, start, end); } TreeNode* helper(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder, int inStart int inEnd) { static int inPre = 0;\tint index = search(inorder, preorder[inPre]); inPre++; subroot-\u0026gt;left = helper(preorder, inorder, inStart, index-1); subroot-\u0026gt;right = helper(preorder, inorder, index+1, inEnd); } int main() { int in[] = {1,2,3,489866,5}; char pre[] = { 'A', 'B', 'D', 'E', 'C', 'F' }; int len = sizeof(in); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; }  LeetCode 965 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; //Usually helper functions are void function. void helper(TreeNode* subroot, int value, bool\u0026amp; judge) { if (subroot == NULL) return; if (subroot-\u0026gt;val != value) judge = false; helper(subroot-\u0026gt;left, value, judge); helper(subroot-\u0026gt;right, value, judge); } bool isUnivalTree(TreeNode* root) { if (root == NULL) return true; int value = root-\u0026gt;val; bool isUT = true; helper(root, value , isUT); return isUT; } int main() { TreeNode* first = new TreeNode(2); TreeNode* second = new TreeNode(3); TreeNode* third = new TreeNode(2); TreeNode* fourth = new TreeNode(2); TreeNode* fifth = new TreeNode(2); TreeNode* null = NULL; first-\u0026gt;left = second; first-\u0026gt;right = third; second-\u0026gt;left = fourth; second-\u0026gt;right = fifth; cout \u0026lt;\u0026lt; isUnivalTree(null) \u0026lt;\u0026lt; endl; return 0; }  Did you find this page helpful? Consider sharing it ðŸ™Œ ","date":1565827200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565827200,"objectID":"9e989003fc24fb89df8b4857d790199e","permalink":"https://diditong.github.io/post/leetcode/","publishdate":"2019-08-15T00:00:00Z","relpermalink":"/post/leetcode/","section":"post","summary":"This is a documentation for LeetCodes LeetCode 009 #include \u0026lt;iostream\u0026gt; using namespace std; /*Revert the whole number //Problematic for very large number bool isPalindrome(int x) { if (x \u0026lt; 0) return false; int x1 = x; int x2 = 0; int lastdig = 0; while (x != 0) { lastdig = x%10; x = x/10; x2 = x2*10+lastdig; } if (x1 == x2) return true; else return false; } */ //Revert half of the number bool isPalindrome(int x) { if (x \u0026lt; 0) return false; //special case: x = 0 or x = 10; if (x \u0026gt; 0 \u0026amp;\u0026amp; x%10 == 0) return false; int x1 = x; int x2 = 0; while (x1 \u0026gt; x2) { x2 = x2*10 + x1%10; x1 = x1/10; } if (x1 == x2) return true; if (x2/10 == x1) return true; return false; } int main() { cout \u0026lt;\u0026lt; isPalindrome(123321) \u0026lt;\u0026lt; endl;\treturn 0; }  LeetCode 011 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; /* int calculateArea(int h1, int h2, dis) { int h = min(h1,h2); int area = h*dis; return area; } */\tint maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int len = height.","tags":null,"title":"Jiashuo's LeetCode Exercise","type":"post"},{"authors":["Jiashuo Tong"],"categories":null,"content":"","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://diditong.github.io/publication/journal-article/","publishdate":"2019-10-09T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"","tags":["Source Themes"],"title":"In Situ Droplet Microgoniometry Using Optical Microscopy","type":"publication"}]